<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Accelerometer Sand</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Prevents pull-to-refresh and other touch gestures from interfering */
        body {
            overscroll-behavior: none;
            touch-action: none;
        }
        canvas {
            display: block;
            background-color: #111827; /* bg-gray-900 */
        }
    </style>
</head>
<body class="overflow-hidden m-0 p-0">

    <!-- Permission overlay -->
    <div id="permission-overlay" class="fixed inset-0 z-10 flex flex-col items-center justify-center bg-gray-900 bg-opacity-95 text-center p-4">
        <h1 class="text-4xl font-bold text-white mb-4">Colorful Sand</h1>
        <p id="info-text" class="text-lg text-gray-300 mb-8 max-w-md">This interactive page uses your device's motion sensors to simulate falling sand. Please grant permission to access the accelerometer.</p>
        <button id="permission-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-8 rounded-lg text-xl shadow-lg transition-transform transform hover:scale-105">
            Start Simulation
        </button>
        <p id="error-message" class="text-red-400 mt-4 hidden"></p>
    </div>

    <!-- The canvas where the sand will be drawn -->
    <canvas id="sand-canvas"></canvas>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('sand-canvas');
        const ctx = canvas.getContext('2d');
        const permissionOverlay = document.getElementById('permission-overlay');
        const permissionButton = document.getElementById('permission-button');
        const infoText = document.getElementById('info-text');
        const errorMessage = document.getElementById('error-message');

        // --- Configuration ---
        const NUM_PARTICLES = 1200;
        const PARTICLE_RADIUS = 3;
        const PARTICLE_FRICTION = 0.80; // How much velocity is lost on wall bounce
        const COLLISION_DAMPING = 0.98; // Energy kept after particle collision
        const GRAVITY_SENSITIVITY = 0.35; // How strongly the accelerometer affects gravity
        const SAND_COLORS = ['#f4a261', '#e76f51', '#2a9d8f', '#264653', '#e9c46a', '#fefae0', '#dda15e'];
        const CELL_SIZE = PARTICLE_RADIUS * 2.5; // For collision optimization grid

        // --- State ---
        let particles = [];
        let gravity = { x: 0, y: 1 };
        let motionSensorWorking = false;
        let grid = [];
        let numCols, numRows;

        // --- Particle Class ---
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.radius = PARTICLE_RADIUS * (0.8 + Math.random() * 0.4); // slight size variation
                this.color = color;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
            }

            update() {
                // Apply gravity
                this.vy += gravity.y;
                this.vx += gravity.x;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wall collision detection and response
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -PARTICLE_FRICTION;
                }
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -PARTICLE_FRICTION;
                }
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= -PARTICLE_FRICTION;
                }
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -PARTICLE_FRICTION;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // --- Collision Handling ---
        function resolveCollisionsForParticle(p1) {
            const p1col = Math.floor(p1.x / CELL_SIZE);
            const p1row = Math.floor(p1.y / CELL_SIZE);

            // Check current cell and 8 neighbors
            for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {
                for (let colOffset = -1; colOffset <= 1; colOffset++) {
                    const checkCol = p1col + colOffset;
                    const checkRow = p1row + rowOffset;

                    if (checkCol >= 0 && checkCol < numCols && checkRow >= 0 && checkRow < numRows) {
                        const index = checkRow * numCols + checkCol;
                        for (const p2 of grid[index]) {
                            if (p1 === p2) continue;

                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const distSq = dx * dx + dy * dy;
                            const radiiSum = p1.radius + p2.radius;

                            if (distSq < radiiSum * radiiSum) {
                                const dist = Math.sqrt(distSq);
                                const overlap = radiiSum - dist;
                                const angle = Math.atan2(dy, dx);
                                
                                const moveX = (overlap / 2) * Math.cos(angle);
                                const moveY = (overlap / 2) * Math.sin(angle);

                                p1.x -= moveX;
                                p1.y -= moveY;
                                p2.x += moveX;
                                p2.y += moveY;

                                // Dampen velocities to simulate inelastic collision
                                p1.vx *= COLLISION_DAMPING;
                                p1.vy *= COLLISION_DAMPING;
                                p2.vx *= COLLISION_DAMPING;
                                p2.vy *= COLLISION_DAMPING;
                            }
                        }
                    }
                }
            }
        }

        // --- Core Functions ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            numCols = Math.ceil(canvas.width / CELL_SIZE);
            numRows = Math.ceil(canvas.height / CELL_SIZE);
            initParticles();
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < NUM_PARTICLES; i++) {
                // Start particles in a cluster at the top center to let them fall into a pile
                const x = canvas.width / 2 + (Math.random() - 0.5) * 80;
                const y = Math.random() * 100;
                const color = SAND_COLORS[Math.floor(Math.random() * SAND_COLORS.length)];
                particles.push(new Particle(x, y, color));
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Populate the spatial grid for collision optimization
            grid = Array(numRows * numCols).fill(null).map(() => []);
            for (const particle of particles) {
                const col = Math.floor(particle.x / CELL_SIZE);
                const row = Math.floor(particle.y / CELL_SIZE);
                if (col >= 0 && col < numCols && row >= 0 && row < numRows) {
                    const index = row * numCols + col;
                    grid[index].push(particle);
                }
            }

            // Update, check collisions, and draw each particle
            particles.forEach(p => {
                resolveCollisionsForParticle(p);
                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        function handleMotionEvent(event) {
            motionSensorWorking = true;
            const accel = event.accelerationIncludingGravity;
            if (accel && accel.x !== null && accel.y !== null) {
                gravity.x = accel.x * GRAVITY_SENSITIVITY;
                gravity.y = -accel.y * GRAVITY_SENSITIVITY;
            }
        }

        function start() {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            initializeSimulation();
                        } else {
                           errorMessage.textContent = 'Permission denied. Please refresh and grant permission to start.';
                           errorMessage.classList.remove('hidden');
                        }
                    })
                    .catch((error) => {
                        console.error(error);
                        errorMessage.textContent = 'An error occurred while requesting permission.';
                        errorMessage.classList.remove('hidden');
                    });
            } else {
                initializeSimulation();
            }
        }

        function initializeSimulation() {
            permissionOverlay.classList.add('hidden');
            window.addEventListener('devicemotion', handleMotionEvent, true);
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            animate();

            // Check if the sensor is actually working after a short delay
            setTimeout(() => {
                if (!motionSensorWorking) {
                    permissionOverlay.classList.remove('hidden');
                    permissionButton.classList.add('hidden');
                    infoText.textContent = "Could not detect motion sensors. The simulation will use default gravity."
                    errorMessage.textContent = 'Your device may not have an accelerometer, or your browser requires a secure (https) connection to access it.';
                    errorMessage.classList.remove('hidden');
                }
            }, 1500);
        }

        // --- Event Listeners ---
        permissionButton.addEventListener('click', start);

    </script>
</body>
</html>

