<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Accelerometer Sand</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Prevents pull-to-refresh and other touch gestures from interfering */
        body {
            overscroll-behavior: none;
            touch-action: none;
        }
        canvas {
            display: block;
            background-color: #111827; /* bg-gray-900 */
        }
        /* Custom styles for range sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568; /* gray-700 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #6366f1; /* indigo-500 */
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #6366f1; /* indigo-500 */
            cursor: pointer;
            border-radius: 50%;
        }
    </style>
</head>
<body class="overflow-hidden m-0 p-0">

    <!-- Permission overlay -->
    <div id="permission-overlay" class="fixed inset-0 z-10 flex flex-col items-center justify-center bg-gray-900 bg-opacity-95 text-center p-4">
        <h1 class="text-4xl font-bold text-white mb-4">Colorful Sand</h1>
        <p id="info-text" class="text-lg text-gray-300 mb-6 max-w-md">Use the settings below to customize the simulation, then grant permission to begin.</p>
        
        <!-- Settings Panel -->
        <div id="settings-panel" class="w-full max-w-sm bg-gray-800 p-6 rounded-lg shadow-xl text-white mb-8 space-y-4">
            <!-- Gravity Setting -->
            <div class="setting-item">
                <div class="flex justify-between items-center mb-1">
                    <label for="gravity-slider" class="font-medium">Gravity</label>
                    <span id="gravity-value" class="text-sm text-indigo-300">0.15</span>
                </div>
                <input id="gravity-slider" type="range" min="0" max="50" value="15">
            </div>
            <!-- Bounciness Setting -->
            <div class="setting-item">
                <div class="flex justify-between items-center mb-1">
                    <label for="bounciness-slider" class="font-medium">Bounciness</label>
                    <span id="bounciness-value" class="text-sm text-indigo-300">0.80</span>
                </div>
                <input id="bounciness-slider" type="range" min="0" max="100" value="80">
            </div>
             <!-- Particle Size Setting -->
             <div class="setting-item">
                <div class="flex justify-between items-center mb-1">
                    <label for="size-slider" class="font-medium">Particle Size</label>
                    <span id="size-value" class="text-sm text-indigo-300">5</span>
                </div>
                <input id="size-slider" type="range" min="1" max="15" value="5">
            </div>
             <!-- Particle Count Setting -->
             <div class="setting-item">
                <div class="flex justify-between items-center mb-1">
                    <label for="count-slider" class="font-medium">Particle Count</label>
                    <span id="count-value" class="text-sm text-indigo-300">4800</span>
                </div>
                <input id="count-slider" type="range" min="500" max="10000" step="100" value="4800">
            </div>
            <!-- Tap to Add Setting -->
            <div class="flex items-center justify-center pt-2">
                 <input id="tap-to-add-checkbox" type="checkbox" class="h-5 w-5 rounded bg-gray-700 border-gray-600 text-indigo-500 focus:ring-indigo-500">
                 <label for="tap-to-add-checkbox" class="ml-3 font-medium">Enable Double Tap to Add</label>
            </div>
            <!-- Reset Button -->
            <div class="pt-4">
                <button id="reset-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm">
                    Reset to Defaults
                </button>
            </div>
        </div>

        <button id="permission-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-8 rounded-lg text-xl shadow-lg transition-transform transform hover:scale-105">
            Start Simulation
        </button>
        <p id="error-message" class="text-red-400 mt-4 hidden"></p>
    </div>

    <!-- The canvas where the sand will be drawn -->
    <canvas id="sand-canvas"></canvas>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('sand-canvas');
        const ctx = canvas.getContext('2d');
        const permissionOverlay = document.getElementById('permission-overlay');
        const permissionButton = document.getElementById('permission-button');
        const infoText = document.getElementById('info-text');
        const errorMessage = document.getElementById('error-message');
        const resetButton = document.getElementById('reset-button');
        
        // --- Settings Elements ---
        const gravitySlider = document.getElementById('gravity-slider');
        const bouncinessSlider = document.getElementById('bounciness-slider');
        const sizeSlider = document.getElementById('size-slider');
        const countSlider = document.getElementById('count-slider');
        const tapToAddCheckbox = document.getElementById('tap-to-add-checkbox');
        const gravityValue = document.getElementById('gravity-value');
        const bouncinessValue = document.getElementById('bounciness-value');
        const sizeValue = document.getElementById('size-value');
        const countValue = document.getElementById('count-value');

        // --- Default Settings ---
        const defaultSettings = {
            gravity: 15, bounciness: 80, size: 5, count: 4800, tapToAdd: false
        };

        // --- Configuration (will be updated by settings) ---
        let NUM_PARTICLES, PARTICLE_RADIUS, PARTICLE_FRICTION, COLLISION_DAMPING, GRAVITY_SENSITIVITY, tapToAddEnabled;
        const DRAG_FORCE = 0.8;
        const SAND_COLORS = ['#f4a261', '#e76f51', '#2a9d8f', '#264653', '#e9c46a', '#fefae0', '#dda15e'];
        let CELL_SIZE;

        // --- State ---
        let particles = [];
        let gravity = { x: 0, y: 0.4 };
        let motionSensorWorking = false;
        let grid = [];
        let numCols, numRows;
        let lastTap = 0;
        let isDragging = false;
        let lastPointerPos = { x: 0, y: 0 };

        // --- Settings Management ---
        function applySettingsToUI(settings) {
            gravitySlider.value = settings.gravity;
            bouncinessSlider.value = settings.bounciness;
            sizeSlider.value = settings.size;
            countSlider.value = settings.count;
            tapToAddCheckbox.checked = settings.tapToAdd;
            gravityValue.textContent = (settings.gravity / 100).toFixed(2);
            bouncinessValue.textContent = (settings.bounciness / 100).toFixed(2);
            sizeValue.textContent = settings.size;
            countValue.textContent = settings.count;
        }

        function saveSettings() {
            const currentSettings = {
                gravity: gravitySlider.value, bounciness: bouncinessSlider.value, size: sizeSlider.value,
                count: countSlider.value, tapToAdd: tapToAddCheckbox.checked
            };
            localStorage.setItem('sandSimSettings', JSON.stringify(currentSettings));
        }

        function loadSettings() {
            const savedSettings = localStorage.getItem('sandSimSettings');
            applySettingsToUI(savedSettings ? JSON.parse(savedSettings) : defaultSettings);
        }

        function resetSettings() {
            localStorage.removeItem('sandSimSettings');
            loadSettings();
        }

        // --- Event Listeners for Settings ---
        window.addEventListener('DOMContentLoaded', loadSettings);
        resetButton.addEventListener('click', resetSettings);
        gravitySlider.addEventListener('input', () => gravityValue.textContent = (gravitySlider.value / 100).toFixed(2));
        bouncinessSlider.addEventListener('input', () => bouncinessValue.textContent = (bouncinessSlider.value / 100).toFixed(2));
        sizeSlider.addEventListener('input', () => sizeValue.textContent = sizeSlider.value);
        countSlider.addEventListener('input', () => countValue.textContent = countSlider.value);

        // --- Particle Class ---
        class Particle {
            constructor(x, y, color, vx = (Math.random() - 0.5) * 2, vy = (Math.random() - 0.5) * 2) {
                this.x = x; this.y = y; this.radius = PARTICLE_RADIUS * (0.8 + Math.random() * 0.4);
                this.color = color; this.vx = vx; this.vy = vy;
            }
            update() {
                this.vy += gravity.y; this.vx += gravity.x; this.x += this.vx; this.y += this.vy;
                if (this.x + this.radius > canvas.width) { this.x = canvas.width - this.radius; this.vx *= -PARTICLE_FRICTION; }
                if (this.x - this.radius < 0) { this.x = this.radius; this.vx *= -PARTICLE_FRICTION; }
                if (this.y + this.radius > canvas.height) { this.y = canvas.height - this.radius; this.vy *= -PARTICLE_FRICTION; }
                if (this.y - this.radius < 0) { this.y = this.radius; this.vy *= -PARTICLE_FRICTION; }
            }
            draw() {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill();
            }
        }

        // --- Collision Handling ---
        function resolveCollisionsForParticle(p1) {
            const p1col = Math.floor(p1.x / CELL_SIZE), p1row = Math.floor(p1.y / CELL_SIZE);
            for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {
                for (let colOffset = -1; colOffset <= 1; colOffset++) {
                    const checkCol = p1col + colOffset, checkRow = p1row + rowOffset;
                    if (checkCol >= 0 && checkCol < numCols && checkRow >= 0 && checkRow < numRows) {
                        for (const p2 of grid[checkRow * numCols + checkCol]) {
                            if (p1 === p2) continue;
                            const dx = p2.x - p1.x, dy = p2.y - p1.y, distSq = dx * dx + dy * dy;
                            const radiiSum = p1.radius + p2.radius;
                            if (distSq < radiiSum * radiiSum && distSq > 0) {
                                const dist = Math.sqrt(distSq), overlap = (radiiSum - dist) / dist;
                                const moveX = dx * 0.5 * overlap, moveY = dy * 0.5 * overlap;
                                p1.x -= moveX; p1.y -= moveY; p2.x += moveX; p2.y += moveY;
                                p1.vx *= COLLISION_DAMPING; p1.vy *= COLLISION_DAMPING;
                                p2.vx *= COLLISION_DAMPING; p2.vy *= COLLISION_DAMPING;
                            }
                        }
                    }
                }
            }
        }

        // --- Core Functions ---
        function resizeCanvas() {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            numCols = Math.ceil(canvas.width / CELL_SIZE); numRows = Math.ceil(canvas.height / CELL_SIZE);
            initParticles();
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const x = canvas.width / 2 + (Math.random() - 0.5) * 80, y = Math.random() * 100;
                particles.push(new Particle(x, y, SAND_COLORS[Math.floor(Math.random() * SAND_COLORS.length)]));
            }
        }

        function addParticlesAt(x, y) {
            const clumpSize = 20 + Math.random() * 30;
            for(let i=0; i < clumpSize; i++) {
                const angle = Math.random() * Math.PI * 2, speed = Math.random() * 4;
                particles.push(new Particle(x, y, SAND_COLORS[Math.floor(Math.random() * SAND_COLORS.length)], Math.cos(angle) * speed, Math.sin(angle) * speed));
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            grid = Array(numRows * numCols).fill(null).map(() => []);
            for (const p of particles) {
                const col = Math.floor(p.x / CELL_SIZE), row = Math.floor(p.y / CELL_SIZE);
                if (col >= 0 && col < numCols && row >= 0 && row < numRows) grid[row * numCols + col].push(p);
            }
            particles.forEach(p => { resolveCollisionsForParticle(p); p.update(); p.draw(); });
            requestAnimationFrame(animate);
        }

        // --- Event Handlers ---
        function handlePointerDown(e) {
            isDragging = true; lastPointerPos = { x: e.clientX, y: e.clientY };
            if (tapToAddEnabled) {
                const now = Date.now(), timeSince = now - lastTap;
                if (timeSince < 300 && timeSince > 0) {
                    addParticlesAt(e.clientX, e.clientY); isDragging = false;
                }
                lastTap = now;
            }
        }

        function handlePointerMove(e) {
            if (!isDragging) return;
            const dx = e.clientX - lastPointerPos.x, dy = e.clientY - lastPointerPos.y;
            const col = Math.floor(e.clientX / CELL_SIZE), row = Math.floor(e.clientY / CELL_SIZE);
            for (let rOff = -1; rOff <= 1; rOff++) for (let cOff = -1; cOff <= 1; cOff++) {
                const c = col + cOff, r = row + rOff;
                if (c >= 0 && c < numCols && r >= 0 && r < numRows) for (const p of grid[r * numCols + c]) {
                    const p_dx = p.x - e.clientX, p_dy = p.y - e.clientY;
                    if (p_dx * p_dx + p_dy * p_dy < 900) { p.vx += dx * DRAG_FORCE; p.vy += dy * DRAG_FORCE; } // 30px radius
                }
            }
            lastPointerPos = { x: e.clientX, y: e.clientY };
        }

        function handlePointerUp() { isDragging = false; }

        function handleMotionEvent(event) {
            motionSensorWorking = true;
            const accel = event.accelerationIncludingGravity;
            if (accel && accel.x !== null && accel.y !== null) {
                gravity.x = -accel.x * GRAVITY_SENSITIVITY; gravity.y = accel.y * GRAVITY_SENSITIVITY;
            }
        }

        function start() {
            saveSettings();
            GRAVITY_SENSITIVITY = parseFloat(gravitySlider.value) / 100;
            const bounciness = parseFloat(bouncinessSlider.value) / 100;
            PARTICLE_FRICTION = bounciness; COLLISION_DAMPING = 0.90 + (bounciness * 0.09);
            PARTICLE_RADIUS = parseInt(sizeSlider.value, 10); NUM_PARTICLES = parseInt(countSlider.value, 10);
            tapToAddEnabled = tapToAddCheckbox.checked; CELL_SIZE = PARTICLE_RADIUS * 2.5;

            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(state => {
                    if (state === 'granted') initializeSimulation();
                    else { errorMessage.textContent = 'Permission denied.'; errorMessage.classList.remove('hidden'); }
                }).catch(err => { console.error(err); errorMessage.textContent = 'Error requesting permission.'; errorMessage.classList.remove('hidden'); });
            } else { initializeSimulation(); }
        }

        function initializeSimulation() {
            permissionOverlay.classList.add('hidden');
            canvas.addEventListener('pointerdown', handlePointerDown);
            canvas.addEventListener('pointermove', handlePointerMove);
            canvas.addEventListener('pointerup', handlePointerUp);
            canvas.addEventListener('pointerleave', handlePointerUp);
            window.addEventListener('devicemotion', handleMotionEvent, true);
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); animate();
            setTimeout(() => {
                if (!motionSensorWorking) {
                    permissionOverlay.classList.remove('hidden'); permissionButton.classList.add('hidden');
                    infoText.textContent = "Could not detect motion sensors. Default gravity will be used."
                    errorMessage.textContent = 'Your device may lack an accelerometer or require a secure (https) connection.';
                    errorMessage.classList.remove('hidden');
                }
            }, 1500);
        }
        permissionButton.addEventListener('click', start);
    </script>
</body>
</html>

